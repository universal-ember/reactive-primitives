{"version":3,"file":"function.js","sources":["../src/function.ts"],"sourcesContent":["import { tracked } from '@glimmer/tracking';\nimport { assert } from '@ember/debug';\nimport { associateDestroyableChild, destroy, isDestroyed, isDestroying } from '@ember/destroyable';\n\nimport { TrackedAsyncData } from 'ember-async-data';\nimport { resource } from 'ember-resources';\n\ninterface CallbackMeta {\n  isRetrying: boolean;\n}\n\n/**\n * Any tracked data accessed in a tracked function _before_ an `await`\n * will \"entangle\" with the function -- we can call these accessed tracked\n * properties, the \"tracked prelude\". If any properties within the tracked\n * payload  change, the function will re-run.\n *\n * ```js\n * import Component from '@glimmer/component';\n * import { tracked } from '@glimmer/tracking';\n * import { resourceFactory, resource, use } from 'ember-resources';\n * import { trackedFunction }  from 'reactiveweb/function';\n * import { on } from '@ember/modifier';\n *\n * function Request(idFn) {\n *   return resource(({use}) => {\n *     let trackedRequest = use(trackedFunction(async () => {\n *       let id = idFn();\n *       let response = await fetch(`https://swapi.dev/api/people/${id}`);\n *       let data = await response.json();\n *\n *       return data; // { name: 'Luke Skywalker', ... }\n *     }));\n *\n *     return trackedRequest;\n *   });\n * }\n *\n * class Demo extends Component {\n *   @tracked id = 1;\n *\n *   updateId = (event) => this.id = event.target.value;\n *\n *   request = use(this, Request(() => this.id));\n *\n *   // Renders \"Luke Skywalker\"\n *   <template>\n *     {{this.request.current.value.name}}\n *\n *     <input value={{this.id}} {{on 'input' this.updateId}}>\n *   </template>\n * }\n * ```\n */\nexport function trackedFunction<Return>(\n  fn: (meta: {\n    /**\n     * true when state.retry() is called, false initially\n     * and also false when tracked data changes (new initial)\n     */\n    isRetrying: boolean;\n  }) => Return\n): State<Return>;\n\n/**\n * Any tracked data accessed in a tracked function _before_ an `await`\n * will \"entangle\" with the function -- we can call these accessed tracked\n * properties, the \"tracked prelude\". If any properties within the tracked\n * payload  change, the function will re-run.\n *\n * ```js\n * import Component from '@glimmer/component';\n * import { tracked } from '@glimmer/tracking';\n * import { trackedFunction }  from 'reactiveweb/function';\n *\n * class Demo extends Component {\n *   @tracked id = 1;\n *\n *   request = trackedFunction(this, async () => {\n *     let response = await fetch(`https://swapi.dev/api/people/${this.id}`);\n *     let data = await response.json();\n *\n *     return data; // { name: 'Luke Skywalker', ... }\n *   });\n *\n *   updateId = (event) => this.id = event.target.value;\n *\n *   // Renders \"Luke Skywalker\"\n *   <template>\n *     {{this.request.value.name}}\n *\n *     <input value={{this.id}} {{on 'input' this.updateId}}>\n *   </template>\n * }\n * ```\n * _Note_, this example uses the proposed `<template>` syntax from the [First-Class Component Templates RFC][rfc-799]\n *\n * Also note that after an `await`, the `this` context should not be accessed as it could lead to\n * destruction/timing issues.\n *\n * [rfc-799]: https://github.com/emberjs/rfcs/pull/779\n *\n * @param {Object} context destroyable parent, e.g.: component instance aka \"this\"\n * @param {Function} fn the function to run with the return value available on .value\n */\nexport function trackedFunction<Return>(\n  context: object,\n  fn: (meta: {\n    /**\n     * true when state.retry() is called, false initially\n     * and also false when tracked data changes (new initial)\n     */\n    isRetrying: boolean;\n  }) => Return\n): State<Return>;\n\nexport function trackedFunction<Return>(\n  ...args: Parameters<typeof directTrackedFunction<Return>> | Parameters<typeof classUsable<Return>>\n): State<Return> {\n  if (args.length === 1) {\n    return classUsable(...args);\n  }\n\n  if (args.length === 2) {\n    return directTrackedFunction(...args);\n  }\n\n  assert('Unknown arity: trackedFunction must be called with 1 or 2 arguments');\n}\n\nconst START = Symbol.for('__reactiveweb_trackedFunction__START__');\n\nfunction classUsable<Return>(fn: (meta: CallbackMeta) => Return) {\n  const state = new State(fn);\n\n  let destroyable = resource<State<Return>>(() => {\n    state[START]();\n\n    return state;\n  });\n\n  associateDestroyableChild(destroyable, state);\n\n  return destroyable;\n}\n\nfunction directTrackedFunction<Return>(context: object, fn: (meta: CallbackMeta) => Return) {\n  const state = new State(fn);\n\n  let destroyable = resource<State<Return>>(context, () => {\n    state[START]();\n\n    return state;\n  });\n\n  associateDestroyableChild(destroyable, state);\n\n  return destroyable;\n}\n\n/**\n * State container that represents the asynchrony of a `trackedFunction`\n */\nexport class State<Value> {\n  @tracked data: TrackedAsyncData<Value> | null = null;\n  @tracked declare promise: Value;\n\n  /**\n   * ember-async-data doesn't catch errors,\n   * so we can't rely on it to protect us from \"leaky errors\"\n   * during rendering.\n   *\n   * See also: https://github.com/qunitjs/qunit/issues/1736\n   */\n  @tracked caughtError: unknown;\n\n  #fn: (meta: CallbackMeta) => Value;\n\n  constructor(fn: (meta: CallbackMeta) => Value) {\n    this.#fn = fn;\n  }\n\n  get state(): TrackedAsyncData<Value>['state'] | 'UNSTARTED' {\n    return this.data?.state ?? 'UNSTARTED';\n  }\n\n  /**\n   * Initially true, and remains true\n   * until the underlying promise resolves or rejects.\n   */\n  get isPending() {\n    if (!this.data) return true;\n\n    return this.data.isPending ?? false;\n  }\n\n  /**\n   * Alias for `isResolved || isRejected`\n   */\n  get isFinished() {\n    return this.isResolved || this.isRejected;\n  }\n\n  /**\n   * Alias for `isFinished`\n   * which is in turn an alias for `isResolved || isRejected`\n   */\n  get isSettled() {\n    return this.isFinished;\n  }\n\n  /**\n   * Alias for `isPending`\n   */\n  get isLoading() {\n    return this.isPending;\n  }\n\n  /**\n   * When true, the function passed to `trackedFunction` has resolved\n   */\n  get isResolved() {\n    return this.data?.isResolved ?? false;\n  }\n\n  /**\n   * Alias for `isRejected`\n   */\n  get isError() {\n    return this.isRejected;\n  }\n\n  /**\n   * When true, the function passed to `trackedFunction` has errored\n   */\n  get isRejected() {\n    return this.data?.isRejected ?? Boolean(this.caughtError) ?? false;\n  }\n\n  /**\n   * this.data may not exist yet.\n   *\n   * Additionally, prior iterations of TrackedAsyncData did\n   * not allow the accessing of data before\n   * .state === 'RESOLVED'  (isResolved).\n   *\n   * From a correctness standpoint, this is perfectly reasonable,\n   * as it forces folks to handle the states involved with async functions.\n   *\n   * The original version of `trackedFunction` did not use TrackedAsyncData,\n   * and did not have these strictnesses upon property access, leaving folks\n   * to be as correct or as fast/prototype-y as they wished.\n   *\n   * For now, `trackedFunction` will retain that flexibility.\n   */\n  get value(): Awaited<Value> | null {\n    if (this.data?.isResolved) {\n      // This is sort of a lie, but it ends up working out due to\n      // how promises chain automatically when awaited\n      return this.data.value as Awaited<Value>;\n    }\n\n    return null;\n  }\n\n  /**\n   * When the function passed to `trackedFunction` throws an error,\n   * that error will be the value returned by this property\n   */\n  get error() {\n    if (this.state === 'UNSTARTED' && this.caughtError) {\n      return this.caughtError;\n    }\n\n    if (this.data?.state !== 'REJECTED') {\n      return null;\n    }\n\n    if (this.caughtError) {\n      return this.caughtError;\n    }\n\n    return this.data?.error ?? null;\n  }\n\n  async [START]() {\n    try {\n      await this._dangerousRetry({ isRetrying: false });\n    } catch (e) {\n      if (isDestroyed(this) || isDestroying(this)) return;\n      this.caughtError = e;\n    }\n  }\n\n  /**\n   * Will re-invoke the function passed to `trackedFunction`\n   * this will also re-set some properties on the `State` instance.\n   * This is the same `State` instance as before, as the `State` instance\n   * is tied to the `fn` passed to `trackedFunction`\n   *\n   * `error` or `resolvedValue` will remain as they were previously\n   * until this promise resolves, and then they'll be updated to the new values.\n   */\n  retry = async () => {\n    try {\n      /**\n       * This function has two places where it can error:\n       * - immediately when inovking `fn` (where auto-tracking occurs)\n       * - after an await, \"eventually\"\n       */\n      await this._dangerousRetry({ isRetrying: true });\n    } catch (e) {\n      if (isDestroyed(this) || isDestroying(this)) return;\n      this.caughtError = e;\n    }\n  };\n\n  _dangerousRetry = async ({ isRetrying }: CallbackMeta) => {\n    if (isDestroyed(this) || isDestroying(this)) return;\n\n    // We've previously had data, but we're about to run-again.\n    // we need to do this again so `isLoading` goes back to `true` when re-running.\n    // NOTE: we want to do this _even_ if this.data is already null.\n    //       it's all in the same tracking frame and the important thing is taht\n    //       we can't *read* data here.\n    this.data = null;\n\n    // this._internalError = null;\n\n    // We need to invoke this before going async so that tracked properties are consumed (entangled with) synchronously\n    this.promise = this.#fn({ isRetrying });\n\n    // TrackedAsyncData interacts with tracked data during instantiation.\n    // We don't want this internal state to entangle with `trackedFunction`\n    // so that *only* the tracked data in `fn` can be entangled.\n    await Promise.resolve();\n\n    /**\n     * Before we await to start a new request, let's clear our error.\n     * This is detached from the tracking frame (via the above await),\n     * se the UI can update accordingly, without causing us to refetch\n     */\n    this.caughtError = null;\n\n    if (this.data) {\n      let isUnsafe = isDestroyed(this.data) || isDestroying(this.data);\n\n      if (!isUnsafe) {\n        destroy(this.data);\n        this.data = null;\n      }\n    }\n\n    if (isDestroyed(this) || isDestroying(this)) return;\n\n    // TrackedAsyncData manages the destroyable child association for us\n    this.data = new TrackedAsyncData(this.promise);\n\n    return this.promise;\n  };\n}\n"],"names":["trackedFunction","args","length","classUsable","directTrackedFunction","assert","START","Symbol","for","fn","state","State","destroyable","resource","associateDestroyableChild","context","g","prototype","tracked","i","void 0","constructor","data","isPending","isFinished","isResolved","isRejected","isSettled","isLoading","isError","Boolean","caughtError","value","error","_dangerousRetry","isRetrying","e","isDestroyed","isDestroying","retry","promise","Promise","resolve","isUnsafe","destroy","TrackedAsyncData"],"mappings":"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"}